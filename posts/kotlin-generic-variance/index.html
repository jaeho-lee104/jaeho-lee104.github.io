<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="naver-site-verification" content="db781b5d18dbb68b7802908ad338738d2e6bb107"/><meta name="layout-lang" content="en"><meta name="day-prompt" content="d ago"><meta name="hour-prompt" content="hr ago"><meta name="minute-prompt" content="min ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://blog2-320917.appspot.com/query?id=ag52fmJsb2cyLTMyMDkxN3IVCxIIQXBpUXVlcnkYgICAmJSmwwoM"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="코틀린 변성에 대한 이해" /><meta name="author" content="leejaeho" /><meta property="og:locale" content="en" /><meta name="description" content="변성(variance)이란?" /><meta property="og:description" content="변성(variance)이란?" /><link rel="canonical" href="https://jaeho-lee104.github.io/posts/kotlin-generic-variance/" /><meta property="og:url" content="https://jaeho-lee104.github.io/posts/kotlin-generic-variance/" /><meta property="og:site_name" content="jaeho’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-13T03:45:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="코틀린 변성에 대한 이해" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leejaeho" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leejaeho"},"description":"변성(variance)이란?","headline":"코틀린 변성에 대한 이해","url":"https://jaeho-lee104.github.io/posts/kotlin-generic-variance/","@type":"BlogPosting","dateModified":"2020-07-13T03:45:00+08:00","datePublished":"2020-07-13T03:45:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jaeho-lee104.github.io/posts/kotlin-generic-variance/"},"@context":"https://schema.org"}</script><title>코틀린 변성에 대한 이해 | jaeho's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="jaeho's blog"><meta name="application-name" content="jaeho's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://blog2-320917.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://blog2-320917.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang=""><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/blog/main.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">jaeho's blog</a></div><div class="site-subtitle font-italic">🐠</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jaeho-lee104" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['contact','leejaeho.dev'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>코틀린 변성에 대한 이해</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>코틀린 변성에 대한 이해</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leejaeho </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Jul 13, 2020, 3:45 AM +0800" >Jul 13, 2020<i class="unloaded">2020-07-13T03:45:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2233 words">12 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><h1 id="변성variance이란">변성(variance)이란?</h1><p><strong>기저 타입(base type)</strong>이 같고 <strong>타입 인자(type argument)</strong>가 다른 경우 서로 어떤 관계가 있는지 설명하는 개념이다.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;,</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;</span>
</pre></table></code></div></div><p>여기서 <code class="language-plaintext highlighter-rouge">List</code>는 기저 타입, <code class="language-plaintext highlighter-rouge">&lt;String&gt;, &lt;Any&gt;</code> 는 타입 인자다.</p><p>이런 개념에 대해 왜 알아야 할까 ?</p><p>String 과 Any의 관계는 간단하게 말할 수 있다. <code class="language-plaintext highlighter-rouge">String은 Any의 하위 타입이다.</code></p><ul><li>하위 타입 : 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면, 타입 B는 타입 A의 하위 타입이다.</ul><p>그렇다면 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>은 <code class="language-plaintext highlighter-rouge">List&lt;Any&gt;</code>의 하위 타입일까?</p><p>결론은 ‘아니다’</p><p><br /></p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">addInvalidValue</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;){</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="s">"text"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kd">val</span> <span class="py">numbers</span> <span class="p">=</span> <span class="nf">mutableListOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// MutableList&lt;Int&gt;</span>
    <span class="nf">addInvalidValue</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// compile error</span>
<span class="p">}</span>
</pre></table></code></div></div><center>[코드 1-1]</center><p><br /></p><p>만약 위의 경우 에러가 발생하지 않을 경우 list에 의도치 않은 타입인자가 add 될 수 있다.</p><p><code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>은 <code class="language-plaintext highlighter-rouge">List&lt;Any&gt;</code>의 하위 타입이 아니며, 이 둘은 아무런 관계가 없다. - 무공변(invariant)</p><p>하지만, <code class="language-plaintext highlighter-rouge">MutableList&lt;Int&gt;</code> 를 사용한다고 해서 항상 <code class="language-plaintext highlighter-rouge">MutableList&lt;Int&gt;</code>가 필요한 것은 아니다.</p><p>다음 코드를 보자.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">printList</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;){</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="nf">joinToString</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kd">val</span> <span class="py">numbers</span> <span class="p">=</span> <span class="nf">mutableListOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// MutableList&lt;Int&gt;</span>
    <span class="nf">printList</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// compile error</span>
<span class="p">}</span>
</pre></table></code></div></div><center>[코드 1-2]</center><p><br /></p><p>위와 같을 경우 printList 함수에서 단순히 list element들의 toString을 이어준 결과 값을 출력하고자 하는 것이기에 굳이 <code class="language-plaintext highlighter-rouge">MutableList&lt;Int&gt;</code>가 필요하지 않다. <code class="language-plaintext highlighter-rouge">MutableList&lt;Any&gt;</code> 이어도 list에 영향을 미치지 않고, 값을 오류 없이 읽어서 출력할 수 있다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">printList(numbers)</code> 는 컴파일 오류를 발생시킨다. 왜냐면 <code class="language-plaintext highlighter-rouge">MutableList&lt;Any&gt;</code> 와 <code class="language-plaintext highlighter-rouge">MutableList&lt;Int&gt;</code>는 아무런 관계가 없기 때문.</p><p>이 둘의 관계를 정의하여 <code class="language-plaintext highlighter-rouge">printList(numbers)</code> 의 오류를 없애고, printList 함수의 활용성을 보다 확장할 수 있게하는 것 그게 <strong>변성</strong>이다.</p><p>변성을 잘 활용하면 사용에 불편하지 않으면서 타입 안정성을 보장하는 API를 만들 수 있다.</p><p><br /></p><h1 id="in-out">in, out</h1><p>코틀린에서 변성을 지정할 수 있게 2가지 키워드를 제공한다. <code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">out</code> 이다.</p><p>다음과 같은 클래스가 있다고 가정해보자</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Variance</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span>
</pre></table></code></div></div><ul><li>B가 A의 하위 타입일 때 <code class="language-plaintext highlighter-rouge">Variance&lt;B&gt;</code>는 <code class="language-plaintext highlighter-rouge">Variance&lt;A&gt;</code>의 하위 타입이다. 라는 관계를 지정하고 싶다면 <code class="language-plaintext highlighter-rouge">out</code> 키워드를 사용하면 되며, <code class="language-plaintext highlighter-rouge">class Variance&lt;out T&gt;</code> 과 같이 작성하면 된다. 이를 <code class="language-plaintext highlighter-rouge">공변적</code> 이다. 라고 표현한다. - 공변성(covariance)<li>B가 A의 하위 타입일 때 <code class="language-plaintext highlighter-rouge">Variance&lt;A&gt;</code>는 <code class="language-plaintext highlighter-rouge">Variance&lt;B&gt;</code>의 하위 타입이다. 라는 관계를 지정하고 싶다면 <code class="language-plaintext highlighter-rouge">in</code> 키워드를 사용하면 되며, <code class="language-plaintext highlighter-rouge">class Variance&lt;in T&gt;</code> 과 같이 작성하면 된다. 이를 <code class="language-plaintext highlighter-rouge">반공변적</code> 이다. 라고 표현한다. - 반공변성(contravariance)</ul><p><code class="language-plaintext highlighter-rouge">out</code> 키워드를 이용하여 [코드 1-2] 를 개선해보자</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">printList</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="k">out</span> <span class="nc">Any</span><span class="p">&gt;){</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="nf">joinToString</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kd">val</span> <span class="py">numbers</span> <span class="p">=</span> <span class="nf">mutableListOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// MutableList&lt;Int&gt;</span>
    <span class="nf">printList</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1">// compile success</span>
<span class="p">}</span>
</pre></table></code></div></div><center>[코드 1-3]</center><p><br /></p><p>printList 함수 인자 list의 타입 <code class="language-plaintext highlighter-rouge">MutableList&lt;Any&gt;</code> 를 <code class="language-plaintext highlighter-rouge">MutableList&lt;out Any&gt;</code>로 수정하여, Any의 하위 타입을 타입 인자로 갖는 MutableList를 허용하게 되어 코드 컴파일 및 printList 함수가 정상적으로 실행된다.</p><p>그렇다면 <code class="language-plaintext highlighter-rouge">in</code>과 <code class="language-plaintext highlighter-rouge">out</code>은 상하위 타입 간에 호환성을 지정하고 싶을 때 아무 조건 없이 사용해도 되는걸까?</p><p><br /></p><h1 id="in-out-에-대한-이해"><code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">out</code> 에 대한 이해</h1><p>kotlin 라이브러리 인터페이스를 살펴보면서 언제 써야 좋을지에 대해 이해해보자.</p><h2 id="out"><code class="language-plaintext highlighter-rouge">out</code></h2><p>List 인터페이스를 보면 다음과 같이 정의되어 있다.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="p">&lt;</span><span class="k">out</span> <span class="nc">E</span><span class="p">&gt;</span> <span class="p">:</span> <span class="nc">Collection</span><span class="p">&lt;</span><span class="nc">E</span><span class="p">&gt;</span> <span class="p">{</span>

    <span class="k">public</span> <span class="k">operator</span> <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">E</span>

<span class="p">}</span>
</pre></table></code></div></div><center>[코드 1-4]</center><p><br /></p><p>List interface에서 get 함수는 제네릭으로 지정된 타입의 객체를 반환하는 함수다. 그리고 List의 제네릭 타입 선언 부분을 보면 <code class="language-plaintext highlighter-rouge">&lt;out E&gt;</code>로 작성 되어있다. 왜 <code class="language-plaintext highlighter-rouge">in</code>이 아닌 <code class="language-plaintext highlighter-rouge">out</code>을 지정했을까?</p><p>다음과 같이 코드가 선언되어 있다고 가정해보자.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">val</span> <span class="py">charSequenceList</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">CharSequence</span><span class="p">&gt;</span>
<span class="kd">val</span> <span class="py">stringList</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">listOf</span><span class="p">(</span><span class="s">"abc"</span><span class="p">,</span> <span class="s">"123"</span><span class="p">)</span>
<span class="kd">val</span> <span class="py">anyList</span><span class="p">:</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">listOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

</pre></table></code></div></div><center>[코드 1-5]</center><p><br /></p><p>charSequenceList 에서 get() 함수를 호출했을 때 기대하는 결과는 CharSequence 타입의 객체를 반환하는 것이다.</p><p>어떤 리스트에서 get() 함수를 호했을 때 CharSequence 라는 타입을 반환할 수 있는 리스트는</p><p>CharSequence의 하위 타입을 타입 인자로 갖는 리스트일 것이다. ( stringList 반환 가능, anyList 반환 불가능 )</p><p>stringList는 get() 함수에서만큼은 charSequenceList 의 역할을 대체할 수 있다.</p><p>단순히 해당 타입의 객체를 <code class="language-plaintext highlighter-rouge">반환</code>하는 것이 목적이라면, 타입 인자의 하위 타입에 대해 공변적이다.</p><p>정리하면 <code class="language-plaintext highlighter-rouge">지정된 제네릭 타입을 반환할 수 있는 것은 타입 인자의 하위 타입을 타입 인자로 갖는 객체들이고, 그런 객체들과의 호환성을 허용하게 해주는 것이 out 키워드</code> 이다.</p><p>여기서 반환 값에서의 공변관계의 포인트는 해당 값을 단순히 반환한다는 시각으로 보는 것보다 해당 값을 반환할 수 있냐라는 시각으로 보는 것이 이해에 도움이 될 수 있다. <code class="language-plaintext highlighter-rouge">반환할 수 있는 녀석에게는 나를 대신하게 허용해주겠다</code> 라는 의미</p><blockquote><p>지정된 타입을 <code class="language-plaintext highlighter-rouge">반환할 수 있다</code>는 말은 해당 타입을 <code class="language-plaintext highlighter-rouge">생산해낼 수 있다</code>는 것으로도 해석할 수 있다. 코틀린을 다루는 여러 문서에서 특정 타입을 반환하는 것을 생산한다고 표현하는 것을 볼 수 있다.</p></blockquote><h2 id="in"><code class="language-plaintext highlighter-rouge">in</code></h2><p>Comparable interface를 보면 다음과 같이 정의되어 있다.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="k">in</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="p">{</span>

    <span class="k">public</span> <span class="k">operator</span> <span class="k">fun</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="nc">T</span><span class="p">):</span> <span class="nc">Int</span>

<span class="p">}</span>
</pre></table></code></div></div><center>[코드 1-6]</center><p><br /></p><p>Comparable interface에서 compareTo 함수는 제네릭으로 지정된 타입의 객체를 비교하는 함수다. (객체 간의 대소 비교를 가능하게 함) 그리고 Comparable 제네릭 타입 선언 부분을 보면 <code class="language-plaintext highlighter-rouge">&lt;in T&gt;</code>로 작성 되어있다. 왜 <code class="language-plaintext highlighter-rouge">out</code>이 아닌 <code class="language-plaintext highlighter-rouge">in</code>을 지정했을까?</p><p>다음과 같이 선언되어 있다고 가정해보자.</p><div lang="kotlin" class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">val</span> <span class="py">charSequenceComparable</span><span class="p">:</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="nc">CharSequence</span><span class="p">&gt;</span>
<span class="kd">val</span> <span class="py">stringComparable</span><span class="p">:</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;</span>
<span class="kd">val</span> <span class="py">anyComparable</span><span class="p">:</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;</span>
</pre></table></code></div></div><center>[코드 1-7]</center><p><br /></p><p>charSequenceComparable는 정렬과 같은 로직에 활용되기 위해 CharSequence 객체 간의 크기 비교에 대해 정의한 <code class="language-plaintext highlighter-rouge">Comparable&lt;CharSequence&gt;</code> 타입의 객체다. charSequenceComparable의 경우 비교 로직을 작성할 때 CharSequence의 length를 이용하여 비교했을 수도 있고, hashCode() 값을 이용했을 수도 있다. length 값을 비교했다면 CharSequence의 프로퍼티를 이용하여 비교한 것이므로 특이점은 없다. 하지만 hashCode()를 이용했다면 그것은 CharSequence의 상위 타입의 객체도 가지고 있는 것이므로 Comparable의 타입이 꼭 CharSequence 일 필요는 없다. 그럴 경우 <code class="language-plaintext highlighter-rouge">Comparable&lt;Any&gt;</code>로 <code class="language-plaintext highlighter-rouge">Comparable&lt;CharSequence&gt;</code>를 대신하는 것에 전혀 문제가 없다. 즉, Comparable의 compareTo 함수의 경우 상위 타입에 대해 호환이 가능하므로 반공변적인 관계를 지정할 수 있다. <code class="language-plaintext highlighter-rouge">Comparable&lt;String&gt;</code>과 같은 하위 타입의 타입 인자를 갖는 경우 어떤 추가적인 프로퍼티를 이용하여 비교 로직이 작성되어 있을지 모르니 해당 타입으로 CharSequence를 비교하는 것은 불가능하다. 함수의 인자에서 사용될 경우 제네릭에 지정된 타입을 대체할 수 있어야하므로 하위 타입과는 호환이 불가능하며 상위 타입과는 호환이 가능하다. 정리하면 <code class="language-plaintext highlighter-rouge">함수 인자에서 제네릭 타입이 사용될 경우, 제네릭 타입 인자의 상위 타입을 타입 인자로 갖는 객체들은 이미 포함하고 있는 내용을 활용하고 있으므로 호환성을 허용해도 문제가 없으며, 이를 지정하는 것이 in 키워드</code> 이다.</p><p><code class="language-plaintext highlighter-rouge">제네릭에 지정된 타입이 함수의 인자에서 사용된 정보를 포함하는지</code>가 포인트이며, 당연하게도 타입 인자의 하위 타입을 갖는 객체들과는 호환이 되지 않는다.</p><p>이렇게 <code class="language-plaintext highlighter-rouge">in</code>, <code class="language-plaintext highlighter-rouge">out</code> 키워드를 사용하여 공변 및 반공변 관계를 정의하여 API의 타입 안정성을 유지하며 활용성을 높일 수 있다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/kotlin/'>Kotlin</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/covariance/" class="post-tag no-text-decoration" >covariance</a> <a href="/tags/contravariance/" class="post-tag no-text-decoration" >contravariance</a> <a href="/tags/generic/" class="post-tag no-text-decoration" >generic</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=코틀린 변성에 대한 이해 - jaeho's blog&url=https://jaeho-lee104.github.io/posts/kotlin-generic-variance/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=코틀린 변성에 대한 이해 - jaeho's blog&u=https://jaeho-lee104.github.io/posts/kotlin-generic-variance/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=코틀린 변성에 대한 이해 - jaeho's blog&url=https://jaeho-lee104.github.io/posts/kotlin-generic-variance/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/kotlin-sam/">Kotlin SAM</a><li><a href="/posts/navigation-popup/">android navigation 사용시 백스택 추가하지 않고 이동</a><li><a href="/posts/git-config/">git commit name, email 설정</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android-studio/">Android Studio</a> <a class="post-tag" href="/tags/android-tv/">Android TV</a> <a class="post-tag" href="/tags/assets/">Assets</a> <a class="post-tag" href="/tags/charles/">Charles</a> <a class="post-tag" href="/tags/contravariance/">contravariance</a> <a class="post-tag" href="/tags/covariance/">covariance</a> <a class="post-tag" href="/tags/fresco/">Fresco</a> <a class="post-tag" href="/tags/functional-interface/">functional interface</a> <a class="post-tag" href="/tags/generic/">generic</a> <a class="post-tag" href="/tags/git-config/">git config</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/kotlin-sam/"><div class="card-body"> <span class="timeago small" >Jul 28<i class="unloaded">2021-07-28T23:19:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kotlin SAM</h3><div class="text-muted small"><p> android를 kotlin으로 개발하다보면 다음과 같은 코드를 자주 작성하게 된다. 1 2 3 view.setOnClickListener { ... } 코틀린 특성상 메소드의 마지막 파라미터가 람다식인 경우 () 뒤에 { ... } 블록을 작성할 수 있다. 하지만 view.setOnClickListener 메소드를 확인해보면 다음과...</p></div></div></a></div><div class="card"> <a href="/posts/charles-proxy-with-android-tv/"><div class="card-body"> <span class="timeago small" >Aug 8<i class="unloaded">2021-08-08T00:42:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android TV 에서 charles proxy 설정</h3><div class="text-muted small"><p> Charles를 이용하여 네트워크 트래픽을 보려면 현재 연결되어 있는 네트워크에 proxy 설정을 해주면 된다. https 와 같이 ssl proxying 이 필요한 경우에는 Charles 인증서를 설치해주어야 한다. 인증서 별도 설치가 필요한 이유에 대해 간단히 설명하면, Charles 는 Client &lt;-&gt; Charles (pr...</p></div></div></a></div><div class="card"> <a href="/posts/fresco-with-assets/"><div class="card-body"> <span class="timeago small" >Jul 28<i class="unloaded">2021-07-28T14:56:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>fresco 로컬 asset 파일 읽기</h3><div class="text-muted small"><p> webp 또는 그 외 다른 이미지 파일들을 app assets 폴더에 저장하고 사용하는 케이스가 있다. 보통 fresco 는 웹 상의 이미지를 로드하기에 편리해서 사용했는데 로컬에 있는 파일을 읽어들일 때는 어떻게 하면 될까. 단순히 절대경로나 상대경로를 사용해서는 안된다. fresco 문서에 보면 지원하는 uri 타입들에 대해 다음과 같이 정의...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/android-studio-run-error/" class="btn btn-outline-primary" prompt="Newer"><p>error running 'app' default activity not found</p></a></div><script src="https://utteranc.es/client.js" repo="jaeho-lee104/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">leejaeho</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android-studio/">Android Studio</a> <a class="post-tag" href="/tags/android-tv/">Android TV</a> <a class="post-tag" href="/tags/assets/">Assets</a> <a class="post-tag" href="/tags/charles/">Charles</a> <a class="post-tag" href="/tags/contravariance/">contravariance</a> <a class="post-tag" href="/tags/covariance/">covariance</a> <a class="post-tag" href="/tags/fresco/">Fresco</a> <a class="post-tag" href="/tags/functional-interface/">functional interface</a> <a class="post-tag" href="/tags/generic/">generic</a> <a class="post-tag" href="/tags/git-config/">git config</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://jaeho-lee104.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-171055976-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-171055976-1'); }); </script>
